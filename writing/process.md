## The Process - Making my language
First, I read around, finding [this Medium post](https://medium.freecodecamp.org/the-programming-language-pipeline-91d3f449c919) to be useful. While a lot of the stuff went over my head, I gleaned that it would make it easier for me if I changed the code of my language into something more readable for the computer before running it. So, I made a *lexer* first, to convert the raw code to a list of lines, each one containing a command and a list of *parameters* to give to that command. You can find this file [here](../src/lexer.js).

Then, I decided to make a function that resolved mathematical expressions like `5 + 5` and `10 ** 2` (`**` means `to the power of`). You can find that file [here](../src/parseMathExpression.js).

After that, I decided to make the "native" commands. These commands are simple things like `print` and `if` that would be built in to the language. However, I found out that it would be hard to test these without an *interpreter*, something that, for the sake of my simpler project, would take the code and run it. What surprised me was that the interpreter was actually very simple to make---it's the shortest file in my program---and it's structure hasn't changed much ever since I started it. Likewise, after figuring out the format that my functions would be in, it was very simple to just keep adding each one with a specific context. You can find the interpreter [here](../src/interpreter.js) and the native functions/variables file [here](../src/varsAndFuncs.js)

Finally, I had to handle decisions. I was too lazy to design an interpreter like the one used in the math expression parser, so I made one based off of a list of arguments, making it a bit different from mainstream language. You can find that file [here](../src/parseEqExpression.js)

While I was finishing up my language, I realized that I had forgotten a vital part of any basic and advanced programming language: taking user input! Node.JS, the tool I used to build the language, already has a built-in input/output module called `readline`, however it uses *asynchrony*, meaning that while it was waiting for input it wouldn't block the rest of the program, and that wouldn't fit in my simple language. Therefore, I had to decide to use [`readline-sync`](https://npmjs.com/readline-sync), a *module* (set of code someone else wrote) that would do it *synchronously*, meaning that it *would* wait for user input before continuing the program. "But Victor," you might ask, "why didn't you just use the methods that the author of readline-sync used?" I looked at readline-sync's code, and I noticed that they used not only JavaScript but code that used different languages that had those methods. (For the techies: they used sh code and powershell code to make their module work on Windows, macOS, and Linux). I am not very proficient in the languages that they used, so I decided to go along with their solution---even if I tried to build my own, it probably wouldn't've been that compatibile with all operating systems and computers.

Then, I decided to expand the if statements by adding elif and else into the mix.

Finally, I realized I had a bunch of bugs in the way I handled nested loops, so I worked hard, over many days, to fix the bug. I now realize what I could have done to prevent it, and if I ever had the chance to do this project again I certainly would do it in the first place and make my life a whole lot easier. However, the code works now, so there's no need to fuss. 
